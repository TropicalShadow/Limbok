package club.tesseract.limbo.properties;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.minestom.server.coordinate.Pos;
import net.minestom.server.entity.GameMode;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.*;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Locale;
import java.util.Properties;

@Slf4j
@Getter
public class ServerProperties {

    private final static String FILE_HEADER = "Server properties\nAuto-generated by Limbo\nDefault found at https://github.com/TropicalShadow/Limbo/blob/main/src/main/resources/server.properties\n";

    // File linked to the server properties
    @NotNull
    private final File file;

    // Server properties
    @NotNull
    private final String serverIp;
    private final int serverPort;

    // Game mode
    @NotNull
    private final GameMode gameMode;

    // Server Settings
    @NotNull
    private final ProxyMode proxyMode;
    @Nullable
    private final String proxySecretFile;

    // World properties
    @NotNull
    private final String worldName;
    @Nullable
    private final String schematicName;
    private final int worldPreloadChunks;
    @NotNull
    private final Pos worldSpawnPosition;
    @Nullable
    private final Integer worldVoidHeight;

    public ServerProperties(@NotNull File file) throws IOException {
        this.file = file;

        final String defaultResourceFilename = "server.properties";
        InputStream defaultValues = getClass().getClassLoader().getResourceAsStream(defaultResourceFilename);
        if(defaultValues == null) {
            throw new RuntimeException("Default server properties not found: " + defaultResourceFilename);
        }
        InputStreamReader defaultValuesReader = new InputStreamReader(defaultValues, StandardCharsets.UTF_8);

        Properties defaultProperties = new Properties();
        defaultProperties.load(defaultValuesReader);
        defaultValuesReader.close();

        Properties properties = new Properties(defaultProperties);
        defaultProperties.forEach(properties::putIfAbsent);

        if(file.exists()) properties.load(file.toURI().toURL().openStream());
        else {
            OutputStream os = Files.newOutputStream(file.toPath());
            URL resourceUrl = getClass().getClassLoader().getResource(defaultResourceFilename);
            if(resourceUrl == null) {
                throw new RuntimeException("Default server properties not found: " + defaultResourceFilename);
            }
            try {
                Files.copy(Path.of(resourceUrl.toURI()), os);
            }catch (Exception e){
                throw new RuntimeException("Failed to copy default server properties", e);
            }
        }

        saveProperties(file, properties);

        this.serverIp = properties.getProperty("server-ip");
        this.serverPort = Integer.parseInt(properties.getProperty("server-port"));

        String gameMode = properties.getProperty("game-mode");
        this.gameMode = GameMode.valueOf(gameMode.toUpperCase(Locale.ROOT));

        // Server Settings
        String proxyMode = properties.getProperty("proxy-mode");
        this.proxyMode = ProxyMode.fromString(proxyMode);
        String proxySecretFile = properties.getProperty("proxy-secret-file");
        if(proxySecretFile.trim().isBlank()){
            this.proxySecretFile = null;
        }else{
            this.proxySecretFile = proxySecretFile;
        }


        // World Settings

        this.worldName = properties.getProperty("world-name");
        this.schematicName = properties.getProperty("world-schematic");
        this.worldPreloadChunks = Integer.parseInt(properties.getProperty("world-preload-chunks"));
        final String spawnLocation = properties.getProperty("world-spawn-location");
        if(spawnLocation != null) {
            String[] split = spawnLocation.split(",");
            if (split.length == 3) {
                worldSpawnPosition = new Pos(
                        Double.parseDouble(split[0]),
                        Double.parseDouble(split[1]),
                        Double.parseDouble(split[2])
                );
            } else if(split.length > 4){
                worldSpawnPosition = new Pos(
                        Double.parseDouble(split[0]),
                        Double.parseDouble(split[1]),
                        Double.parseDouble(split[2]),
                        Float.parseFloat(split[3]),
                        Float.parseFloat(split[4])
                );
            }else{
                throw new IllegalArgumentException("Invalid spawn location format: " + spawnLocation);
            }
        }else{
            throw new IllegalArgumentException("Spawn location not found in server properties");
        }

        String worldVoidHeightProperty = properties.getProperty("world-void-height");
        if(worldVoidHeightProperty != null && !worldVoidHeightProperty.trim().isBlank()) {
            this.worldVoidHeight = Integer.parseInt(worldVoidHeightProperty);
        }else{
            this.worldVoidHeight = null;
        }

        log.info("Server properties loaded from file: {}", file.getAbsolutePath());
    }

    void saveProperties(File file, Properties properties) throws IOException {
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(Files.newOutputStream(file.toPath()), StandardCharsets.UTF_8));
        properties.store(pw, FILE_HEADER);
        pw.close();
    }

}
